{
    "url": "https://www.appdome.com/how-to/advanced-threat-intelligence-android-ios/threat-events-ux-ui-control/use-threat-events-in-flutter-apps",
    "title": "Appdome | Threat-Events\u2122, In-App Threat Intelligence in Flutter Apps with Obj-C & Java",
    "content": "Appdome | Threat-Events\u2122, In-App Threat Intelligence in Flutter Apps with Obj-C & Java\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n![](https://pubads.g.doubleclick.net/activity;xsp=4798079;ord=1?)\n\n\n\n ![](https://px.ads.linkedin.com/collect/?pid=3167484&fmt=gif)\n\n\n\n\nMenu\n\n[Sign In](https://fusion.appdome.com/login)\n\n[![Appdome Logo](https://www.appdome.com/wp-content/uploads/elementor/thumbs/appdome-logo-r88bnmyou58sjra0z25z48awn6epdjpr0vb010dhxc.png \"Appdome Logo\")](/)\n\n[How to](https://www.appdome.com/how-to/) \n > \n[Advanced Threat Intelligence](https://www.appdome.com/how-to/advanced-threat-intelligence-android-ios/)\n > \n[Threat-Events\u2122 UX/UI Control](https://www.appdome.com/how-to/advanced-threat-intelligence-android-ios/threat-events-ux-ui-control/)\n > \n[Threat-Events\u2122, In-App Threat Intelligence in Flutter Apps with Obj-C & Java](https://www.appdome.com/how-to/advanced-threat-intelligence-android-ios/threat-events-ux-ui-control/use-threat-events-in-flutter-apps/)\n\n# Threat-Events\u2122, In-App Threat Intelligence in Flutter Apps with Obj-C & Java\n\nLast updated July 13, 2025 by Appdome\n\nThis guide walks you through integrating Appdome\u2019s Threat-Events\u2122 into your Flutter applications, offering a step-by-step approach for enhancing mobile app security.\n\n## What are Threat-Events?\n\nAppdome Threat-Events is a robust threat-intelligence framework for Android and iOS apps. It consists of three elements: a Threat Event, the data from each Threat Event, and the Threat-Score\u2122.\n\nThreat-Events streamlines the process for mobile developers by enabling them to register for, listen to, and consume real-time attack and threat data, courtesy of Appdome\u2019s suite of mobile app security, anti-fraud, and mobile anti-bot protection measures. This functionality offers mobile app developers the ability to customize business logic and user experience based on the user\u2019s risk profile and the specific attack or threat presented but also ensures that their mobile application workflows are aware of attacks and threats. Furthermore, it facilitates the passing of threat data to other systems of record, such as app servers, mobile fraud analysis systems, SIEMs, and other data collection points.\n\nThe purpose of Threat-Events is to enable Android and iOS applications to adapt and respond to mobile app attacks and threats in real-time. This will ensure the safety of user data and transactions.\n\n## Mobile Application Threat-Events vs. Threat-Scores\n\nAppdome Threat-Events can be used as a stand-alone implementation in Flutter Apps or in combination with Threat Scores. Threat-Events provide in-app notifications of each attack or threat, as well as the metadata associated with the attack. Threat Scores provide the mobile developer with a Threat-Event event score and the combined (aggregated) mobile end-user risk score at the time of the notification.\n\n## Prerequisites\n\nBefore implementing Threat-Events or Threat-Scores in your Flutter App, ensure that the following conditions are met:\n\n* Appdome account ([**create a free Appdome account here**](https://fusion.appdome.com/signup))\n* [**Mobile App**](https://www.appdome.com/how-to/dev-sec-tools/how-appdome-works/begin-no-code-mobile-app-security-project)\u00a0(.ipa for iOS, or .apk or .aab for Android)\n* Appdome account class \u2013 Appdome DEV or higher.\n* Mobile Application Source Code.\n* Signing Credentials (e.g., signing certificates and provisioning profile) \u2013 see\u00a0[**Signing Secure Android apps**](https://www.appdome.com/how-to/appsec-release-orchestration/code-signing-protected-android-ios/code-sign-secured-android-apps-in-devsecops-build-system/) and\u00a0[**Signing Secure iOS apps**](https://www.appdome.com/how-to/appsec-release-orchestration/code-signing-protected-android-ios/appdome-enabling-signing-secured-ios-apps-without-xcode/).\n* Threat-Events and/or Threat-Scores have been enabled ( turned ON) for a specific protection.\n* You are using the correct identifiers for the Threat-Events for each protection.\n\n**Note:** You can find the specific identifiers for each Threat Event and Threat Score in the knowledge base article associated with each protection.\n\nThe figure below shows where you can find Threat Events and Threat Scores for each of the runtime mobile app security, anti-fraud, anti-malware, mobile antibot, and other protections available on Appdome.\n\n## Android\n\n![Root Detection Threat Events](https://www.appdome.com/wp-content/uploads/2024/02/Screenshot-2024-02-28-at-17.09.40.png)\n\n## iOS Jailbreak Detection\n\nTo enable Threat-Events with any runtime protection, select the check box next to Threat-Events for that feature. Doing so will enable (turn ON) Threat-Events for that feature. To enable Threat Scores for any runtime protection, click the up/down arrow associated with Threat Scores to assign a specific score to each protection.  \nThreat-Scores must have a value greater than zero (0) and less than a thousand (1,000).\n\nThreat-Events and Threat-Scores can be used with or in place of server-based mobile anti-fraud solutions.\n\n## Communicating with Native Platforms in Flutter\n\nFlutter provides various approaches to bridge the gap between its Dart code and platform-specific functionality on Android and iOS. Some common options include:\n\n* **Event** **Channels:** This is the go-to method for most situations. It sets up named channels enabling bidirectional communication between Dart and native code.\n* **Platform Views:** This technique allows you to integrate native UI components, granting access to features like maps or cameras directly within your Flutter app.\n* **Method Channels:** A specialized type of platform channel that focuses explicitly on invoking methods on the native side and retrieving results back in Dart.\n\nChoose the approach that best suits your needs when bridging the gap between Flutter and native platforms Threat-Events.\n\n## Prioritizing Security with Event Channels:\n\nEvent channels are the optimal approach for integrating threat events into your Flutter app due to their inherent security-centric advantages:\n\n* **Leveraging Native Security:** Appdome platform functionalities are specifically designed to detect and mitigate security threats on iOS and Android applications. By establishing an event channel, your Flutter app enables Appdome to seamlessly tap into these platform-specific capabilities, gaining access to sophisticated threat detection mechanisms without compromising security by directly accessing native system resources.\n* **Immediate Threat Awareness & Response:** Event channels enable real-time communication between Appdome and your Flutter app, allowing for immediate reports of detected threats.\n\n## Integrating Secure Event Channels into Your Flutter Application:\n\n1. **Adjust EventChannel Name:**\n   * Locate \u05f4**\\_eventChannelName****\u05f4** and replace **\u05f4****yourEventChannel****\u05f4** with a unique and descriptive EventChannel name relevant to your application.\n2. **Customize Event Handling:**\n   * In the \u05f4**\\_onEvent****\u05f4** method, customize the handling of received events based on your specific needs.\n\n     ```\n     import 'dart:async';\r\n     import 'package:flutter/material.dart';\r\n     import 'package:flutter/services.dart';\r\n     class PlatformChannel extends StatefulWidget {\r\n       const PlatformChannel({super.key});\r\n       @override\r\n       State&lt;PlatformChannel&gt; createState() =&gt; _PlatformChannelState();\r\n     }\r\n     class _PlatformChannelState extends State&lt;PlatformChannel&gt; {\r\n       static const String _eventChannelName = 'yourEventChannel'; // Replace with your EventChannel name\r\n       static const EventChannel _eventChannel = EventChannel(_eventChannelName);\r\n       String _currentThreatEvent = 'No ThreatEvent detected';\r\n       String? keyboardID;\r\n       String? keyboardBlocked;\r\n       String? defaultMessage;\r\n       String? timeStamp;\r\n       String? deviceID;\r\n       String? deviceModel;\r\n       String? osVersion;\r\n       String? kernelInfo;\r\n       String? deviceManufacturer;\r\n       String? fusedAppToken;\r\n       String? carrierPlmn;\r\n       String? deviceBrand;\r\n       String? deviceBoard;\r\n       String? buildHost;\r\n       String? buildUser;\r\n       String? sdkVersion;\r\n       @override\r\n       void initState() {\r\n         super.initState();\r\n         _eventChannel.receiveBroadcastStream().listen(_onEvent, onError: _onError);\r\n       }\r\n       void _onEvent(Object? event) {\r\n         setState(() {\r\n           // Adapt this section based on your specific event data structure\r\n           var eventData = event as Map;\r\n           // Example: Accessing 'externalID' field from the event\r\n           var externalID = eventData['externalID'];\r\n           // Customize the rest of the fields based on your event structure\r\n           keyboardID = eventData['keyboard'];\r\n           keyboardBlocked = eventData['blocked'];\r\n           defaultMessage = eventData['defaultMessage'];\r\n           timeStamp = eventData['timestamp'];\r\n           deviceID = eventData['deviceID'];\r\n           deviceModel = eventData['deviceModel'];\r\n           osVersion = eventData['osVersion'];\r\n           kernelInfo = eventData['kernelInfo'];\r\n           deviceManufacturer = eventData['deviceManufacturer'];\r\n           fusedAppToken = eventData['fusedAppToken'];\r\n           carrierPlmn = eventData['carrierPlmn'];\r\n           deviceBrand = eventData['deviceBrand'];\r\n           deviceBoard = eventData['deviceBoard'];\r\n           buildHost = eventData['buildHost'];\r\n           buildUser = eventData['buildUser'];\r\n           sdkVersion = eventData['sdkVersion'];\r\n           _currentThreatEvent = \"Detected ThreatEvent: $externalID.\\n\" +\r\n                                 \"Keyboard ID: $keyboardID\\n\" +\r\n                                 \"Keyboard Blocked: $keyboardBlocked\\n\" +\r\n                                 \"Default Message: $defaultMessage\\n\" +\r\n                                 \"Timestamp: $timeStamp\\n\" +\r\n                                 \"Device ID: $deviceID\\n\" +\r\n                                 \"Device Model: $deviceModel\\n\" +\r\n                                 \"OS Version: $osVersion\\n\" +\r\n                                 \"Kernel Info: $kernelInfo\\n\" +\r\n                                 \"Device Manufacturer: $deviceManufacturer\\n\" +\r\n                                 \"Fused App Token: $fusedAppToken\\n\" +\r\n                                 \"Carrier PLMN: $carrierPlmn\\n\" +\r\n                                 \"Device Brand: $deviceBrand\\n\" +\r\n                                 \"Device Board: $deviceBoard\\n\" +\r\n                                 \"Build Host: $buildHost\\n\" +\r\n                                 \"Build User: $buildUser\\n\" +\r\n                                 \"SDK Version: $sdkVersion\\n\";\r\n         });\r\n       }\r\n       void _onError(Object error) {\r\n         setState(() {\r\n           _currentThreatEvent = 'Failed To Get ThreatEvent: ${error}.';\r\n         });\r\n       }\r\n       @override\r\n       Widget build(BuildContext context) {\r\n         return Material(\r\n           child: Column(\r\n             mainAxisAlignment: MainAxisAlignment.spaceEvenly,\r\n             children: &lt;Widget&gt;[\r\n               Text(_currentThreatEvent),\r\n             ],\r\n           ),\r\n         );\r\n       }\r\n     }\r\n     void main() {\r\n       runApp(const MaterialApp(home: PlatformChannel()));\r\n     }\n     ```\n\n## Platform-Specific iOS Implementation\n\n1. Open your iOS folder in the Flutter project.\n2. Select **AppDelegate.h**\n3. Insert the <FlutterStreamHandler>\n\n   ```\n   #import <UIKit/UIKit.h>\r\n   #import <Flutter/Flutter.h>\r\n   \r\n   @interface AppDelegate : FlutterAppDelegate <FlutterStreamHandler>\r\n   @end\r\n   ```\n4. Select **AppDelegate.m**\n5. Locate @\u201dyourEventChannel\u201d and replace it with a unique and descriptive EventChannel name relevant to your application.\n\n   ```\n   #import \"AppDelegate.h\"\r\n   #import <Flutter/Flutter.h>\r\n   #import \"GeneratedPluginRegistrant.h\"\r\n   #import \"ThreatEventReceiver.h\"\r\n   \r\n   @implementation AppDelegate {\r\n       FlutterEventSink _eventSink;\r\n       ThreatEventReceiver *_threatEventReceiver;\r\n   }\r\n   \r\n   - (BOOL)application:(UIApplication*)application didFinishLaunchingWithOptions:(NSDictionary*)launchOptions {\r\n       [GeneratedPluginRegistrant registerWithRegistry:self];\r\n       FlutterViewController* controller = (FlutterViewController*)self.window.rootViewController;\r\n       FlutterEventChannel* threatEventBridge = [FlutterEventChannel eventChannelWithName:@\"yourEventChannel\" binaryMessenger:controller];\r\n       [threatEventBridge setStreamHandler:self];\r\n       return [super application:application didFinishLaunchingWithOptions:launchOptions];\r\n   }\r\n   \r\n   - (FlutterError*)onListenWithArguments:(id)arguments eventSink:(FlutterEventSink)eventSink {\r\n       _threatEventReceiver = [[ThreatEventReceiver alloc] init];\r\n       _threatEventReceiver.eventSink = eventSink;\r\n       return nil;\r\n   }\r\n   - (FlutterError*)onCancelWithArguments:(id)arguments {\r\n       return nil;\r\n   }\r\n   \r\n   @end\r\n   ```\n6. Select **ThreatEventReceiver.h** file.  \n\n   ```\n   #import <Foundation/Foundation.h>\r\n   #import <Flutter/Flutter.h>\r\n   @interface ThreatEventReceiver : NSObject\r\n   @property (nonatomic, copy) FlutterEventSink eventSink;\r\n   - (instancetype)init;\r\n   @end\n   ```\n7. Open the **ThreatEventReceiver.m**\u00a0 file.\n8. Modify the event list to fit with the event names you selected during the fuse to be passed as ThreatEvent.\n\n   ```\n   #import \"ThreatEventReceiver.h\"\r\n   @implementation ThreatEventReceiver\r\n   - (instancetype)init {\r\n       self = [super init];\r\n       if (self) {\r\n           // List of constant names\r\n           NSArray<NSString *> *notificationNames = @[ // Replace with your event names\r\n               @\"JailbrokenDevice\"\r\n           ];\r\n           // Add observers for each constant name\r\n           for (NSString *notificationName in notificationNames) {\r\n               [[NSNotificationCenter defaultCenter] addObserver:self \r\n                                                     selector:@selector(handleNotification:) \r\n                                                     name:notificationName \r\n                                                     object:nil];\r\n           }\r\n       }\r\n       return self;\r\n   }\r\n   - (void)dealloc {\r\n       // Remove all observers when the object is deallocated\r\n       [[NSNotificationCenter defaultCenter] removeObserver:self];\r\n       if (self.eventSink) {\r\n           self.eventSink = nil;\r\n       }\r\n   }\r\n   - (void)handleNotification:(NSNotification *)notification {\r\n       // Handle the notification here\r\n       NSLog(@\"Received notification: %@\", notification.name);\r\n       if (!self.eventSink) return;\r\n       if (notification.name) {\r\n           self.eventSink([notification userInfo]);\r\n       } else {\r\n           self.eventSink([FlutterError errorWithCode:@\"UNAVAILABLE\"\r\n                                           message:@\"ThreatEvent action is null\"\r\n                                           details:nil]);\r\n       }\r\n   }\r\n   @end\n   ```\n\n## Platform-Specific Android Implementation \u2013 Java\n\n1. Open your Android folder in the Flutter project.\n2. Select the MainActivity.java file\n3. Locate the YOUR\\_EVENT\\_CHANNEL field and replace it with a unique and descriptive EventChannel name relevant to your application.\n\n   ```\n   import androidx.annotation.NonNull;\r\n   import io.flutter.embedding.android.FlutterActivity;\r\n   import io.flutter.embedding.engine.FlutterEngine;\r\n   import io.flutter.plugin.common.EventChannel;\r\n   import io.flutter.plugin.common.EventChannel.EventSink;\r\n   import io.flutter.plugin.common.EventChannel.StreamHandler;\r\n   public class MainActivity extends FlutterActivity {\r\n     private static final String YOUR_EVENT_CHANNEL = \"yourEventChannel\"; // Replace with your EventChannel name\r\n     @Override\r\n     public void configureFlutterEngine(@NonNull FlutterEngine flutterEngine) {\r\n       new EventChannel(flutterEngine.getDartExecutor(), YOUR_EVENT_CHANNEL).setStreamHandler(\r\n         new StreamHandler() {\r\n           private ThreatEventReceiver threatEventReceiver;\r\n           @Override\r\n           public void onListen(Object arguments, EventSink events) {\r\n             threatEventReceiver = new ThreatEventReceiver();\r\n             threatEventReceiver.init(MainActivity.this, events);\r\n           }\r\n           @Override\r\n           public void onCancel(Object arguments) {\r\n             threatEventReceiver.stop();\r\n             threatEventReceiver = null;\r\n           }\r\n         }\r\n       );\r\n     }\r\n   }\n   ```\n4. Open the ThreatEventReceiver.java file\n5. Modify the event list to fit with the event names you selected during fuse to be passed as ThreatEvent.  \n   **Note:** Create a ThreatEventReceiver.java file in your application project if you do not have an existing one.\n\n   ```\n   import android.content.BroadcastReceiver;\r\n   import android.content.Context;\r\n   import android.content.Intent;\r\n   import android.content.IntentFilter;\r\n   import android.os.Build;\r\n   import android.os.Bundle;\r\n   import java.util.Map;\r\n   import java.util.HashMap;\r\n   import io.flutter.plugin.common.EventChannel.EventSink;\r\n   public class ThreatEventReceiver {\r\n       private BroadcastReceiver receiver;\r\n       private Context context;\r\n       // Explicitly state that the ThreatEvents BroadcastReceiver should not be exported\r\n       private void registerReceiverWithFlags(IntentFilter intentFilter) {\r\n           if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {\r\n               context.registerReceiver(receiver, intentFilter, Context.RECEIVER_NOT_EXPORTED);\r\n           } else {\r\n               context.registerReceiver(receiver, intentFilter);\r\n           }\r\n       }\r\n       public void init(Context context, final EventSink events) {\r\n           this.context = context;\r\n           receiver = new BroadcastReceiver() {\r\n               @Override\r\n               public void onReceive(Context context, Intent intent) {\r\n                   if (intent.getAction() != null) {\r\n                       Map<String, Object> map = new HashMap<>();\r\n                       Bundle extras = intent.getExtras();\r\n                       if (extras != null) {\r\n                           for (String key : extras.keySet()) {\r\n                               Object value = extras.get(key);\r\n                               map.put(key, value);\r\n                           }\r\n                           events.success(map);\r\n                       }\r\n                   } else {\r\n                       events.error(\"UNAVAILABLE\", \"ThreatEvent action is null\", null);\r\n                   }\r\n               }\r\n           };\r\n           registerReceiverWithFlags(new IntentFilter(\"RootedDevice\"));\r\n       }\r\n       // This method should be called during the Activity.onPause() if the context used when calling the init() method is an Activity context\r\n       public void stop() {\r\n           context.unregisterReceiver(receiver);\r\n       }\r\n   }\r\n   ```\n\n## Compatibility with Android 14\n\nCompatibility with Android 14 is seamless through Flutter EventChannel. Utilizing native platform implementations, the code sample provided above ensures that no modifications are needed to make your app fully compatible with Android 14.\n\n## Special Considerations\n\n* + - Replace the event identifiers in your ThreatEventReceiver according to the selections you made while fusing the application. To find the relevant Threat-Event context key, search for the specific feature via our knowledge base and navigate to the code sample section in the relevant article.\n    - You can stack multiple listeners for various events for comprehensive threat detection and response capabilities.\n    - Refer to the official documentation on [EventChannel](https://api.flutter.dev/flutter/services/EventChannel-class.html), [BroadcastReceiver](https://developer.android.com/develop/background-work/background-tasks/broadcasts), and [NSNotificationCenter](https://developer.apple.com/documentation/foundation/nsnotificationcenter) for detailed information and advanced usage. And Alternative methods of implementation.\n\n  ## Meta-Data for Mobile Application Threat-Events and Threat-Scores\n\n  Below is the list of metadata that can be associated with each mobile application Threat-Event\u00a0and Threat-Score\u00a0in\u00a0Flutter Apps.\n\n  | Threat-Event\u00a0**Context Keys** | |\n  | --- | --- |\n  | message | Message displayed for the user on event |\n  | externalID | The external ID of the event which can be listened via Threat Events |\n  | osVersion | OS version of the current device |\n  | deviceModel | Current device model |\n  | deviceManufacturer | The manufacturer of the current device |\n  | fusedAppToken | The task ID of the Appdome fusion of the currently running app |\n  | kernelInfo | Info about the kernel: system name, node name, release, version and machine. |\n  | carrierPlmn | PLMN of the device |\n  | deviceID | Current device ID |\n  | reasonCode | Reason code of the occurred event |\n  | buildDate | Appdome fusion date of the current application |\n  | devicePlatform | OS name of the current device |\n  | carrierName | Carrier name of the current device |\n  | updatedOSVersion | Is the OS version up to date |\n  | deviceBrand | Brand of the device |\n  | deviceBoard | Board of the device |\n  | buildUser | Build user |\n  | buildHost | Build host |\n  | sdkVersion | Sdk version |\n  | timeZone | Time zone |\n  | deviceFaceDown | Is the device face down |\n  | locationLong | Location long |\n  | locationLat | Location lat |\n  | locationState | Location state |\n  | wifiSsid | Wifi SSID |\n  | wifiSsidPermissionStatus | Wifi SSID permission status |\n\n  Some or all of the meta-data for\u00a0each mobile application Threat-Event\u00a0and Threat-Score can be consumed in\u00a0Flutter Apps\u00a0at the discretion of the mobile developer and used, in combination with other mobile application data, to adapt the business logic or user experience when one or more attacks or threats are present.\n\n  ### Using Conditional Enforcement for Mobile Application Threat-Events and Threat-Scores\n\n  Conditional Enforcement is an extension to Appdome\u2019s mobile application Threat-Event framework. By using conditional enforcement, developers can control when Appdome enforcement of each mobile application protection takes place or invoke backup, failsafe, and enforcement to any in-app enforcement used by the mobile developer.  \n  For more information on using conditional enforcement with your Threat-Event implementation, please contact\u00a0**[support.appdome.com](http://support.appdome.com/)**\n\n  ### Verifying Threat Events in Flutter Apps\n\n  After you have implemented the required Threat-Event code in your Flutter Apps, you can confirm that the Appdome protections in the Flutter Apps properly recognize your Threat-Event implementation by reviewing the Certified Secure\u2122 DevSecOps certificate for your build on Appdome.\n\n  ![Ios Android Cert 2 1000px](https://www.appdome.com/wp-content/uploads/2024/02/IOS-Android-cert_-2-1000px.png)\n\n  When Threat-Events implementation appears to be missing in your mobile application, the following indication will be shown in the Certified Secure DevSecOps certificate:\n\n  **Android**:![Android Missing Threat Events Implementation](https://www.appdome.com/wp-content/uploads/2024/02/Android_Missing_Threat_Events_Implementation-650x130.png)\n* **iOS**:![Ios Missing Threat Events Implementation](https://www.appdome.com/wp-content/uploads/2024/02/ios_missing_threat_events_implementation-650x132.png)\n* For information on how to retrieve the Certified Secure DevSecOps certification for your mobile application on Appdome, please visit the knowledge base article: [Using Certified Secure\u2122 Android & iOS Apps Build Certification in DevOps CI/CD](https://www.appdome.com/how-to/appsec-release-orchestration/certified-secure-android-ios/using-certified-secure-android-ios-apps-build-certification-in-devops-cicd/)\n\n  ### Related Articles\n* + [Threat-Events\u2122, In-App Threat Intelligence in Kotlin Apps](https://www.appdome.com/how-to/advanced-threat-intelligence-android-ios/threat-events-ux-ui-control/threat-events-in-app-threat-intelligence-in-kotlin-apps/)\n  + [Threat-Events\u2122, In-App Threat Intelligence in Native iOS Apps](https://www.appdome.com/how-to/advanced-threat-intelligence-android-ios/threat-events-ux-ui-control/threat-events-in-app-threat-intelligence-in-native-ios-apps/)\n  + [Threat-Events\u2122, In-App Threat Intelligence in React Native Apps](https://www.appdome.com/how-to/advanced-threat-intelligence-android-ios/threat-events-ux-ui-control/threat-events-in-app-threat-intelligence-in-react-native-apps/)\n  + [Threat-Events\u2122, In-App Threat Intelligence in Swift Apps](https://www.appdome.com/how-to/advanced-threat-intelligence-android-ios/threat-events-ux-ui-control/threat-events-in-app-threat-intelligence-in-swift-apps/)\n  + [Threat-Events\u2122, In-App Threat Intelligence in Native Android Apps](https://www.appdome.com/how-to/advanced-threat-intelligence-android-ios/threat-events-ux-ui-control/threat-events-in-app-threat-intelligence-in-native-android-apps/)\n  + [Threat-Events\u2122, In-App Threat Intelligence in Maui, Xamarin Apps](https://www.appdome.com/how-to/advanced-threat-intelligence-android-ios/threat-events-ux-ui-control/threat-events-in-app-threat-intelligence-in-xamarin-apps/)\n  + [Implementing Threat Events \u2013 Best Practices](https://www.appdome.com/how-to/advanced-threat-intelligence-android-ios/threat-events-ux-ui-control/implementing-threat-events-best-practices/)\n  + [How To Implement Threat-Events in Java](https://www.appdome.com/how-to/advanced-threat-intelligence-android-ios/threat-events-ux-ui-control/implementing-threat-events-in-code/)\n\n  ## How Do I Learn More?\n\n  If you have any questions, please send them our way at\u00a0[support.appdome.com](http://support.appdome.com/?__hstc=79098507.4813e3c14dfd72c536ccb23ddc37f504.1718886661975.1732533773850.1732543896795.336&__hssc=79098507.5.1732543896795&__hsfp=3435076530)\u00a0or via the chat window on the Appdome platform.\n\n  ### Thank you!\n\n  Thanks for visiting [**Appdome**](https://www.appdome.com/ \"https://www.appdome.com/\")! Our mission is to secure every app on the planet by making mobile app security easy. We hope we\u2019re living up to the mission with your project. If you don\u2019t already have an account, you can [sign up for free](https://fusion.appdome.com/ \"https://fusion.appdome.com/\").\n\nWant a Demo?\n\nThreat-Events\u2122 UX/UI Control\n\n![](https://www.appdome.com/wp-content/uploads/2020/02/Appdome_Team_Photos_Tom_Tovar_BW.jpg)\n\nTomWe're here to help\n\n\n\n\nWe'll get back to you in 24 hours to schedule your demo.\n\n* [Home Page](https://www.appdome.com/)\n* [Dev+Sec Blog](https://www.appdome.com/dev-sec-blog/)\n* [Request A Demo](https://www.appdome.com/request-a-demo/appdome-home/)\n* [Platform](https://www.appdome.com/devsecops-tool-cicd/)\n* [Pricing](https://www.appdome.com/appdome-pricing/)\n* [About](https://www.appdome.com/about/)\n* [Patents](https://www.appdome.com/legal/patents/)\n* [Knowledge Base](https://www.appdome.com/how-to/)\n* [In The News](https://www.appdome.com/in-the-news/)\n* [Careers we\u2019re hiring!](https://www.appdome.com/about/work-at-appdome/)\n* [Terms Of Use](https://www.appdome.com/legal/terms-of-use/)\n* [Press Releases](https://www.appdome.com/press-releases/)\n* [Privacy Policy](https://www.appdome.com/legal/privacy-policy/)\n* [Contact Us](https://www.appdome.com/contact-us/)\n\n\n\n---\n\nREDWOOD CITY OFFICE\n\n* 3 Twin Dolphin Drive,   \n  Suite 375 Redwood City,   \n  CA 94065\n* Phone: [+1.650.567.6100](tel:+16505676100)   \n  Mobile: [+1.844.360.FUSE (3873)](tel:+1844360FUSE (3873))   \n  Email: [info@appdome.com](mailto:info@appdome.com)\n\nISRAEL OFFICE\n\n* 21 HaArba'a Street,\n* Phone: [+97235568332](tel:+97235568332)   \n  Email: [info@appdome.com](mailto:info@appdome.com)\n\nSearch for:\n\nFollow us\n\n\u00a92026 Appdome, Inc. All rights reserved. This Website requires the use of technical cookies and, with your consent, profiling, and third-party analytics to improve your experience.  \n If you continue to use our Website, or by clicking any items of our Website, you agree to this.\n\nWe use cookies to ensure that we give you the best experience on our website.\nIf you continue to use this site we will assume that you are happy with it.\nOk\n\n ![](https://px.ads.linkedin.com/collect/?pid=3167484&fmt=gif) \n\n## Search Appdome Solutions\n\nSearch\n\nSearch\n\n[![mobile app protection best practices](https://www.appdome.com/wp-content/uploads/2026/01/Mobile-App-Protection-Best-Practices-for-Developers-in-2026-170x111.png)](https://www.appdome.com/dev-sec-blog/mobile-app-protection-best-practices-for-developers/)\n\n### [Mobile App Protection Best Practices for Developers in 2026](https://www.appdome.com/dev-sec-blog/mobile-app-protection-best-practices-for-developers/)\n\nMobile app protection best practices for developers in 2026. Learn how to protect apps from AI malware, bots, ATO, and fraud \u2014 automated with Appdome.\n\nJan Sysmans \n\nJanuary 5, 2026\n\n[![Mobile App Attack Vectors](https://www.appdome.com/wp-content/uploads/2026/01/mobile-app-attack-vectors-170x111.png)](https://www.appdome.com/dev-sec-blog/top-mobile-app-attack-vectors/)\n\n### [Top 10 Mobile App Attack Vectors in 2026 And the Defense Architecture Required to Stop Them](https://www.appdome.com/dev-sec-blog/top-mobile-app-attack-vectors/)\n\nAI malware, deepfakes, and automated bots are the top mobile app attack vectors in 2026. Discover how to stop them with Appdome\u2019s defense architecture defense.\n\nJan Sysmans \n\nJanuary 1, 2026\n\n[![G2 Customer Reviews](https://www.appdome.com/wp-content/uploads/2025/12/G2-Reviews_-2025-Was-a-Banner-Year-for-Appdome-170x111.png)](https://www.appdome.com/dev-sec-blog/g2-customer-reviews-2025-banner-year-appdome/)\n\n### [G2 Customer Reviews Reveal 2025 Was a Banner Year for Appdome](https://www.appdome.com/dev-sec-blog/g2-customer-reviews-2025-banner-year-appdome/)\n\nG2 customer reviews show that 2025 marked a pivotal year for Appdome. The platform gained momentum as enterprises standardized on AI-native automation for mobile security, fraud prevention, and bot defense.\n\nTom Tovar \n\nDecember 28, 2025\n\n[![Android Bootloader Integrity Explained](https://www.appdome.com/wp-content/uploads/2025/12/android-bootloader-integrity-explained-170x111.png)](https://www.appdome.com/dev-sec-blog/android-bootloader-integrity-explained/)\n\n### [Why \u2018Unlocked Bootloader\u2019 Is a Broken Android Security Model](https://www.appdome.com/dev-sec-blog/android-bootloader-integrity-explained/)\n\nAndroid bootloader integrity is often reduced to a locked or unlocked state. This article explains why that model fails and how contextual bootloader signals improve identity and session trust.\n\nLiron Dror \n\nDecember 24, 2025\n\n[Dev+Sec Blog](/dev-sec-blog)\n\n-->"
}