{
    "url": "https://www.appdome.com/how-to/advanced-threat-intelligence-android-ios/threat-events-ux-ui-control/threat-events-in-app-threat-intelligence-in-flutter-apps-with-swift-kotlin-integration",
    "title": "Appdome | Integrate Threat-Events\u2122 with Swift & Kotlin in Flutter Apps",
    "content": "Appdome | Integrate Threat-Events\u2122 with Swift & Kotlin in Flutter Apps\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n![](https://pubads.g.doubleclick.net/activity;xsp=4798079;ord=1?)\n\n\n\n ![](https://px.ads.linkedin.com/collect/?pid=3167484&fmt=gif)\n\n\n\n\nMenu\n\n[Sign In](https://fusion.appdome.com/login)\n\n[![Appdome Logo](https://www.appdome.com/wp-content/uploads/elementor/thumbs/appdome-logo-r88bnmyou58sjra0z25z48awn6epdjpr0vb010dhxc.png \"Appdome Logo\")](/)\n\n[How to](https://www.appdome.com/how-to/) \n > \n[Advanced Threat Intelligence](https://www.appdome.com/how-to/advanced-threat-intelligence-android-ios/)\n > \n[Threat-Events\u2122 UX/UI Control](https://www.appdome.com/how-to/advanced-threat-intelligence-android-ios/threat-events-ux-ui-control/)\n > \n[Integrate Threat-Events\u2122 with Swift & Kotlin in Flutter Apps](https://www.appdome.com/how-to/advanced-threat-intelligence-android-ios/threat-events-ux-ui-control/threat-events-in-app-threat-intelligence-in-flutter-apps-with-swift-kotlin-integration/)\n\n# Integrate Threat-Events\u2122 with Swift & Kotlin in Flutter Apps\n\nLast updated July 13, 2025 by Appdome\n\nThis guide walks you through the integration of Appdome\u2019s Threat-Events\u2122 into your Flutter applications using Swift and Kotlin\n\n## What are Threat-Events?\n\nAppdome Threat-Events is a robust threat-intelligence framework designed for Android and iOS apps. It consists of three key elements:\n\n* **Threat Event**: Specific security incidents detected within the app.\n* **Data from Each Threat Event**: Detailed insights about each incident.\n* **Threat-Score\u2122**: An aggregated risk score reflecting the overall threat level.\n\nThreat-Events streamlines the process for mobile developers by enabling them to register for, listen to, and consume real-time attack and threat data, courtesy of Appdome\u2019s suite of mobile app security, anti-fraud, and mobile anti-bot protection measures. This functionality offers mobile app developers the ability to customize business logic and user experience based on the user\u2019s risk profile and the specific attack or threat presented but also ensures that their mobile application workflows are aware of attacks and threats. Furthermore, it facilitates the passing of threat data to other systems of record, such as app servers, mobile fraud analysis systems, SIEMs, and other data collection points.\n\nThe purpose of Threat Events is to enable Android and iOS applications to adapt and respond to mobile app attacks and threats in real-time. This will ensure the safety of users, data, and transactions.\n\nFor more details on Threat Events, see [Threat-Events in Android & iOS Apps Explained](https://www.appdome.com/how-to/advanced-threat-intelligence-android-ios/threat-events-ux-ui-control/threat-events-in-android-ios-apps-explained/)\n\n## Prerequisites\n\nBefore implementing Threat-Events or Threat-Scores in your Flutter App, ensure that the following conditions are met:\n\n* Appdome account ([**create a free Appdome account here**](https://fusion.appdome.com/signup))\n* [**Mobile App**](https://www.appdome.com/how-to/dev-sec-tools/how-appdome-works/begin-no-code-mobile-app-security-project)\u00a0(.ipa for iOS, or .apk or .aab for Android)\n* Appdome account class \u2013 Appdome DEV or higher.\n* Mobile Application Source Code.\n* Signing Credentials (e.g., signing certificates and provisioning profile) \u2013 see\u00a0[**Signing Secure Android apps**](https://www.appdome.com/how-to/appsec-release-orchestration/code-signing-protected-android-ios/code-sign-secured-android-apps-in-devsecops-build-system/) and\u00a0[**Signing Secure iOS apps**](https://www.appdome.com/how-to/appsec-release-orchestration/code-signing-protected-android-ios/appdome-enabling-signing-secured-ios-apps-without-xcode/).\n* Threat-Events and/or Threat-Scores have been enabled (turned ON) for the specific protection.\n* You are using the correct identifiers for the Threat-Events for each protection.\n\n**Note:** The specific identifiers for each Threat Event and Threat Score are in the knowledge base article associated with each protection.\n\nThe figure below shows where you can find Threat Events and Threat Scores for each of the runtime mobile app security, anti-fraud, anti-malware, mobile antibot, and other protections available on Appdome.\n\n## Android\n\n![Root Detection Threat Events](https://www.appdome.com/wp-content/uploads/2024/02/Screenshot-2024-02-28-at-17.09.40.png)\n\n## iOS Jailbreak Detection\n\nTo enable Threat-Events with any runtime protection, select the check box next to Threat-Events for that feature. Doing so will enable (turn ON) Threat-Events for that feature. To enable Threat Scores for any runtime protection, click the up/down arrow associated with Threat Scores to assign a specific score to each protection.  \nThreat scores must have a value greater than zero (0) and less than a thousand (1,000).\n\nThreat-Events and Threat-Scores can be used with or in place of server-based mobile anti-fraud solutions.\n\n## Communicating with Native Platforms in Flutter\n\nFlutter provides various approaches to bridge the gap between its Dart code and platform-specific functionality on Android and iOS. Some common options include:\n\n* **Event** **Channels:** This is the go-to method for most situations. It sets up named channels enabling bidirectional communication between Dart and native code.\n* **Platform Views:** This technique allows you to integrate native UI components, granting access to features like maps or cameras directly within your Flutter app.\n* **Method Channels:** A specialized type of platform channel, it specifically focuses on invoking methods on the native side and retrieving results back in Dart.\n\nChoose the approach that best suits your needs when bridging the gap between Flutter and native platforms Threat-Events.\n\n## Prioritizing Security with Event Channels:\n\nEvent channels are the optimal approach for integrating threat events into your Flutter app due to their inherent security-centric advantages:\n\n* **Leveraging Native Security:** Appdome platform functionalities are specifically designed to detect and mitigate security threats on iOS and Android applications. By establishing an event channel, your Flutter app enables Appdome to seamlessly tap into these platform-specific capabilities, gaining access to sophisticated threat detection mechanisms without compromising security by directly accessing native system resources.\n* **Immediate Threat Awareness & Response:** Event channels enable real-time communication between Appdome and your Flutter app, allowing for immediate reports of detected threats.\n\n## Integrating Secure Event Channels into Your Flutter Application:\n\n1. **Adjust EventChannel Name:**\n   * Locate \u05f4**\\_eventChannelName****\u05f4**\u00a0and replace\u00a0**\u05f4****yourEventChannel****\u05f4**\u00a0with a unique and descriptive EventChannel name relevant to your application.\n2. **Customize Event Handling:**\n   * In the \u05f4**\\_onEvent****\u05f4** method, customize the handling of received events based on your specific needs.\n\n```\nimport 'dart:async';\r\nimport 'package:flutter/material.dart';\r\nimport 'package:flutter/services.dart';\r\n\r\nclass PlatformChannel extends StatefulWidget {\r\n  const PlatformChannel({super.key});\r\n\r\n  @override\r\n  State createState() => _PlatformChannelState();\r\n}\r\n\r\nclass _PlatformChannelState extends State {\r\n  static const String _eventChannelName = 'yourEventChannel'; // Replace with your EventChannel name\r\n  static const EventChannel _eventChannel = EventChannel(_eventChannelName);\r\n\r\n  String _currentThreatEvent = 'No ThreatEvent detected';\r\n  String? keyboardID;\r\n  String? keyboardBlocked;\r\n  String? defaultMessage;\r\n  String? timeStamp;\r\n  String? deviceID;\r\n  String? deviceModel;\r\n  String? osVersion;\r\n  String? kernelInfo;\r\n  String? deviceManufacturer;\r\n  String? fusedAppToken;\r\n  String? carrierPlmn;\r\n  String? deviceBrand;\r\n  String? deviceBoard;\r\n  String? buildHost;\r\n  String? buildUser;\r\n  String? sdkVersion;\r\n\r\n  @override\r\n  void initState() {\r\n    super.initState();\r\n    _eventChannel.receiveBroadcastStream().listen(_onEvent, onError: _onError);\r\n  }\r\n\r\n  void _onEvent(Object? event) {\r\n    setState(() {\r\n      // Adapt this section based on your specific event data structure\r\n      var eventData = event as Map;\r\n\r\n      // Example: Accessing 'externalID' field from the event\r\n      var externalID = eventData['externalID'];\r\n\r\n      // Customize the rest of the fields based on your event structure\r\n      keyboardID = eventData['keyboard'];\r\n      keyboardBlocked = eventData['blocked'];\r\n      defaultMessage = eventData['defaultMessage'];\r\n      timeStamp = eventData['timestamp'];\r\n      deviceID = eventData['deviceID'];\r\n      deviceModel = eventData['deviceModel'];\r\n      osVersion = eventData['osVersion'];\r\n      kernelInfo = eventData['kernelInfo'];\r\n      deviceManufacturer = eventData['deviceManufacturer'];\r\n      fusedAppToken = eventData['fusedAppToken'];\r\n      carrierPlmn = eventData['carrierPlmn'];\r\n      deviceBrand = eventData['deviceBrand'];\r\n      deviceBoard = eventData['deviceBoard'];\r\n      buildHost = eventData['buildHost'];\r\n      buildUser = eventData['buildUser'];\r\n      sdkVersion = eventData['sdkVersion'];\r\n\r\n      _currentThreatEvent = \"Detected ThreatEvent: $externalID.\\n\"\r\n          \"Keyboard ID: $keyboardID\\n\"\r\n          \"Keyboard Blocked: $keyboardBlocked\\n\"\r\n          \"Default Message: $defaultMessage\\n\"\r\n          \"Timestamp: $timeStamp\\n\"\r\n          \"Device ID: $deviceID\\n\"\r\n          \"Device Model: $deviceModel\\n\"\r\n          \"OS Version: $osVersion\\n\"\r\n          \"Kernel Info: $kernelInfo\\n\"\r\n          \"Device Manufacturer: $deviceManufacturer\\n\"\r\n          \"Fused App Token: $fusedAppToken\\n\"\r\n          \"Carrier PLMN: $carrierPlmn\\n\"\r\n          \"Device Brand: $deviceBrand\\n\"\r\n          \"Device Board: $deviceBoard\\n\"\r\n          \"Build Host: $buildHost\\n\"\r\n          \"Build User: $buildUser\\n\"\r\n          \"SDK Version: $sdkVersion\\n\";\r\n    });\r\n  }\r\n\r\n  void _onError(Object error) {\r\n    setState(() {\r\n      _currentThreatEvent = 'Failed To Get ThreatEvent: ${error}.';\r\n    });\r\n  }\r\n\r\n  @override\r\n  Widget build(BuildContext context) {\r\n    return Material(\r\n      child: Column(\r\n        mainAxisAlignment: MainAxisAlignment.spaceEvenly,\r\n        children: [\r\n          Text(_currentThreatEvent),\r\n        ],\r\n      ),\r\n    );\r\n  }\r\n}\r\n\r\nvoid main() {\r\n  runApp(const MaterialApp(home: PlatformChannel()));\r\n}\r\n```\n\n## **Platform-Specific iOS Implementation \u2013 Swift**\n\n1. Open your iOS folder in the Flutter project.\n2. Select\u00a0**AppDelegate.swift**\n3. Locate \u201dyourEventChannel\u201d and replace it with a unique and descriptive EventChannel name relevant to your application.\n\n   ```\n   import Flutter\r\n   import UIKit\r\n   \r\n   @main\r\n   @objc class AppDelegate: FlutterAppDelegate, FlutterStreamHandler {\r\n       var eventSink: FlutterEventSink?\r\n       var threatEventReceiver: ThreatEventReceiver?\r\n   \r\n       override func application(\r\n           _ application: UIApplication,\r\n           didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?\r\n       ) -> Bool {\r\n           GeneratedPluginRegistrant.register(with: self)\r\n           let controller: FlutterViewController = window?.rootViewController as! FlutterViewController\r\n           let threatEventBridge = FlutterEventChannel(name: \"yourEventChannel\", binaryMessenger: controller.binaryMessenger)\r\n           threatEventBridge.setStreamHandler(self)\r\n           return super.application(application, didFinishLaunchingWithOptions: launchOptions)\r\n       }\r\n   \r\n       func onListen(\r\n           withArguments arguments: Any?,\r\n           eventSink: @escaping FlutterEventSink\r\n       ) -> FlutterError? {\r\n           threatEventReceiver = ThreatEventReceiver()\r\n           threatEventReceiver?.eventSink = eventSink\r\n           return nil\r\n       }\r\n   \r\n       func onCancel(withArguments arguments: Any?) -> FlutterError? {\r\n           return nil\r\n       }\r\n   }\r\n   ```\n4. Open the\u00a0**ThreatEventReceiver.swift** file.\n5. Modify the event list to fit with the event names you selected during the fuse to be passed as ThreatEvent.\n\n   ```\n   import Foundation\r\n   import Flutter\r\n   \r\n   class ThreatEventReceiver: NSObject {\r\n       var eventSink: FlutterEventSink?\r\n   \r\n       override init() {\r\n           super.init()\r\n           // List of constant names\r\n           let notificationNames: [Notification.Name] = [\r\n               Notification.Name(\"BlockedKeyboardEvent\"),\r\n               Notification.Name(\"BlockedClipboardEvent\"),\r\n               Notification.Name(\"JailbrokenDevice\"),\r\n               Notification.Name(\"SslCertificateValidationFailed\"),\r\n               Notification.Name(\"SslNonSslConnection\"),\r\n               Notification.Name(\"SslServerCertificatePinningFailed\"),\r\n               Notification.Name(\"UrlWhitelistFailed\"),\r\n               Notification.Name(\"BlockedScreenCaptureEvent\"),\r\n               Notification.Name(\"SslIncompatibleCipher\"),\r\n               Notification.Name(\"SslIncompatibleVersion\"),\r\n               Notification.Name(\"SslInvalidCertificateChain\"),\r\n               Notification.Name(\"SslInvalidMinRSASignature\"),\r\n               Notification.Name(\"SslInvalidMinECCSignature\"),\r\n               Notification.Name(\"SslInvalidMinDigest\"),\r\n               Notification.Name(\"AppIntegrityError\")\r\n           ]\r\n           \r\n           // Add observers for each constant name\r\n           for notificationName in notificationNames {\r\n               NotificationCenter.default.addObserver(\r\n                   self, \r\n                   selector: #selector(handleNotification(_:)), \r\n                   name: notificationName, \r\n                   object: nil\r\n               )\r\n           }\r\n       }\r\n   \r\n       deinit {\r\n           // Remove all observers when the object is deallocated\r\n           NotificationCenter.default.removeObserver(self)\r\n           eventSink = nil\r\n       }\r\n   \r\n       @objc func handleNotification(_ notification: Notification) {\r\n           // Handle the notification here\r\n           print(\"Received notification: \\(notification.name)\")\r\n           guard let eventSink = eventSink else {\r\n               return\r\n           }\r\n           if let userInfo = notification.userInfo {\r\n               eventSink(userInfo)\r\n           } else {\r\n               eventSink(FlutterError(code: \"UNAVAILABLE\", message: \"ThreatEvent action is null\", details: nil))\r\n           }\r\n       }\r\n   }\r\n   ```\n\n## Platform-Specific Android Implementation \u2013 Kotlin\n\n1. Open your Android folder in the Flutter project.\n2. Select the **MainActivity.kt** file.\n3. Locate the YOUR\\_EVENT\\_CHANNEL field and replace it with a unique and descriptive EventChannel name relevant to your application.\n\n   ```\n   package com.example.threat_intelligence_swift_kotlin\r\n   \r\n   import io.flutter.embedding.android.FlutterActivity\r\n   import io.flutter.embedding.engine.FlutterEngine\r\n   import io.flutter.plugin.common.EventChannel\r\n   import io.flutter.plugin.common.EventChannel.EventSink\r\n   \r\n   class MainActivity : FlutterActivity() {\r\n       private val YOUR_EVENT_CHANNEL = \"yourEventChannel\" // Replace with your EventChannel name\r\n   \r\n       override fun configureFlutterEngine(flutterEngine: FlutterEngine) {\r\n           super.configureFlutterEngine(flutterEngine)\r\n           EventChannel(flutterEngine.dartExecutor.binaryMessenger, YOUR_EVENT_CHANNEL).setStreamHandler(\r\n               object : EventChannel.StreamHandler {\r\n                   private var threatEventReceiver: ThreatEventReceiver? = null\r\n   \r\n                   override fun onListen(arguments: Any?, events: EventSink?) {\r\n                       threatEventReceiver = ThreatEventReceiver()\r\n                       threatEventReceiver!!.init(this@MainActivity, events)\r\n                   }\r\n   \r\n                   override fun onCancel(arguments: Any?) {\r\n                       threatEventReceiver!!.stop()\r\n                       threatEventReceiver = null\r\n                   }\r\n               }\r\n           )\r\n       }\r\n   }\r\n   ```\n4. Open the **ThreatEventReceiver.kt** file\n5. Modify the event list to fit with the event names you selected during the fuse to be passed as ThreatEvent.  \n   **Note:**\u00a0Create a **ThreatEventReceiver.kt** file in your application project if you do not have an existing one.\n\n   ```\n   package com.example.threat_intelligence_swift_kotlin\r\n   import android.content.BroadcastReceiver\r\n   import android.content.Context\r\n   import android.content.Intent\r\n   import android.content.IntentFilter\r\n   import android.os.Build\r\n   import io.flutter.plugin.common.EventChannel.EventSink\r\n   class ThreatEventReceiver {\r\n       private var receiver: BroadcastReceiver? = null\r\n       private var context: Context? = null\r\n       private val TAG = \"ThreatEventReceiver\"\r\n       private val BLOCKED_KEYBOARD = \"BlockedKeyboardEvent\" // Replace with your event names\r\n       private val BLOCKED_CLIPBOARD = \"BlockedClipboardEvent\"\r\n       private val ROOTED_DEVICE = \"RootedDevice\"\r\n       private val UNKNOWN_SOURCES = \"UnknownSourcesEnabled\"\r\n       private val DEVELOPER_OPTIONS = \"DeveloperOptionsEnabled\"\r\n       private val SSL_VALIDATION_FAILED = \"SslCertificateValidationFailed\"\r\n       private val SSL_NON_SSL_CONNECTION = \"SslNonSslConnection\"\r\n       private val SSL_CERT_PINNING_FAILED = \"SslCertificatePinningFailed\"\r\n       private val ACCESS_OUTSIDE_WHITELIST = \"UrlWhitelistFailed\"\r\n       private val SSL_INCOMPATIBLE_CIPHER = \"SslIncompatibleCipher\"\r\n       private val SSL_INCOMPATIBLE_TLS = \"SslIncompatibleVersion\"\r\n       private val SSL_INVALID_CA_CHAIN = \"SslInvalidCertificateChain\"\r\n       private val SSL_INVALID_RSA_SIGNATURE = \"SslInvalidMinRSASignature\"\r\n       private val SSL_INVALID_ECC_SIGNATURE = \"SslInvalidMinECCSignature\"\r\n       private val SSL_INVALID_DIGEST = \"SslInvalidMinDigest\"\r\n       private val BLOCKED_MANUFACTURER = \"BannedManufacturer\"\r\n       // Only available when ONEShield Threat Events are enabled\r\n       private val TAMPERED_APP = \"AppIntegrityError\"\r\n       private val EMULATOR_FOUND = \"EmulatorFound\"\r\n       // Explicitly state that the ThreatEvents BroadcastReceiver should not be exported\r\n       private fun registerReceiverWithFlags(intentFilter: IntentFilter) {\r\n           if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {\r\n               context!!.registerReceiver(receiver, intentFilter, Context.RECEIVER_NOT_EXPORTED)\r\n           } else {\r\n               context!!.registerReceiver(receiver, intentFilter)\r\n           }\r\n       }\r\n       fun init(context: Context?, events: EventSink?) {\r\n           this.context = context\r\n           receiver = object : BroadcastReceiver() {\r\n               override fun onReceive(context: Context, intent: Intent) {\r\n                   if (intent.action != null) {\r\n                       val map: MutableMap<String, Any?> = HashMap()\r\n                       val extras = intent.extras\r\n                       if (extras != null) {\r\n                           for (key in extras.keySet()) {\r\n                               val value = extras[key]\r\n                               map[key] = value\r\n                           }\r\n                           events?.success(map)\r\n                       }\r\n                   } else {\r\n                       events?.error(\"UNAVAILABLE\", \"ThreatEvent action is null\", null)\r\n                   }\r\n               }\r\n           }\r\n           registerReceiverWithFlags(IntentFilter(BLOCKED_KEYBOARD))\r\n           registerReceiverWithFlags(IntentFilter(BLOCKED_CLIPBOARD))\r\n           registerReceiverWithFlags(IntentFilter(ROOTED_DEVICE))\r\n           registerReceiverWithFlags(IntentFilter(UNKNOWN_SOURCES))\r\n           registerReceiverWithFlags(IntentFilter(DEVELOPER_OPTIONS))\r\n           registerReceiverWithFlags(IntentFilter(SSL_VALIDATION_FAILED))\r\n           registerReceiverWithFlags(IntentFilter(SSL_NON_SSL_CONNECTION))\r\n           registerReceiverWithFlags(IntentFilter(SSL_CERT_PINNING_FAILED))\r\n           registerReceiverWithFlags(IntentFilter(ACCESS_OUTSIDE_WHITELIST))\r\n           registerReceiverWithFlags(IntentFilter(SSL_INCOMPATIBLE_CIPHER))\r\n           registerReceiverWithFlags(IntentFilter(SSL_INCOMPATIBLE_TLS))\r\n           registerReceiverWithFlags(IntentFilter(SSL_INVALID_CA_CHAIN))\r\n           registerReceiverWithFlags(IntentFilter(SSL_INVALID_RSA_SIGNATURE))\r\n           registerReceiverWithFlags(IntentFilter(SSL_INVALID_ECC_SIGNATURE))\r\n           registerReceiverWithFlags(IntentFilter(SSL_INVALID_DIGEST))\r\n           registerReceiverWithFlags(IntentFilter(BLOCKED_MANUFACTURER))\r\n           // Only available when ONEShield Threat Events are enabled\r\n           registerReceiverWithFlags(IntentFilter(TAMPERED_APP))\r\n           registerReceiverWithFlags(IntentFilter(EMULATOR_FOUND))\r\n       }\r\n       fun stop() {\r\n           context!!.unregisterReceiver(receiver)\r\n       }\r\n   }\n   ```\n\n## Compatibility with Android 14\n\nCompatibility with Android 14 is seamless through Flutter EventChannel. Utilizing native platform implementations, the code sample provided above ensures that no modifications are needed to make your app fully compatible with Android 14.\n\n## Special Considerations\n\n* + - Replace the event identifiers in your ThreatEventReceiver according to the selections you made while fusing the application. To find the relevant Threat-Event context key, search for the specific feature via our knowledge base and navigate to the code sample section in the relevant article.\n    - You can stack multiple listeners for various events for comprehensive threat detection and response capabilities.\n    - For detailed information, advanced usage, and alternative implementation methods, refer to the official documentation on\u00a0[EventChannel](https://api.flutter.dev/flutter/services/EventChannel-class.html),\u00a0[BroadcastReceiver](https://developer.android.com/develop/background-work/background-tasks/broadcasts), and\u00a0[NSNotificationCenter](https://developer.apple.com/documentation/foundation/nsnotificationcenter).\n\n  ## Meta-Data for Mobile Application Threat-Events and Threat-Scores\n\n  Below is the list of metadata that can be associated with each mobile application, Threat-Event and Threat-Score in\u00a0Flutter Apps.\n\n  | Threat-Event\u00a0**Context Keys** | |\n  | --- | --- |\n  | message | Message displayed for the user on the event |\n  | externalID | The external ID of the event, which can be listened to via Threat Events |\n  | osVersion | OS version of the current device |\n  | deviceModel | Current device model |\n  | deviceManufacturer | The manufacturer of the current device |\n  | fusedAppToken | The task ID of the Appdome fusion of the currently running app |\n  | kernelInfo | Info about the kernel: system name, node name, release, version, and machine. |\n  | carrierPlmn | PLMN of the device |\n  | deviceID | Current device ID |\n  | reasonCode | Reason code of the occurred event |\n  | buildDate | Appdome fusion date of the current application |\n  | devicePlatform | OS name of the current device |\n  | carrierName | Carrier name of the current device |\n  | updatedOSVersion | Is the OS version up to date |\n  | deviceBrand | Brand of the device |\n  | deviceBoard | Board of the device |\n  | buildUser | Build user |\n  | buildHost | Build host |\n  | sdkVersion | Sdk version |\n  | timeZone | Time zone |\n  | deviceFaceDown | Is the device face-down |\n  | locationLong | Location longitude |\n  | locationLat | Location latitude |\n  | locationState | Location state |\n  | wifiSsid | Wifi SSID |\n  | wifiSsidPermissionStatus | Wifi SSID permission status |\n\n  Some or all of the meta-data for\u00a0each mobile application Threat-Event\u00a0and Threat-Score can be consumed in\u00a0Flutter Apps\u00a0at the discretion of the mobile developer and used, in combination with other mobile application data, to adapt the business logic or user experience when one or more attacks or threats are present.\n\n  ### Using Conditional Enforcement for Mobile Application Threat-Events and Threat-Scores\n\n  Conditional Enforcement is an extension to Appdome\u2019s mobile application Threat-Event framework. By using conditional enforcement, developers can control when Appdome enforcement of each mobile application protection takes place or invoke backup, failsafe, and enforcement to any in-app enforcement used by the mobile developer.\n\n  ### Verifying Threat-Events in Flutter Apps\n\n  After you have implemented the required Threat-Event code in your Flutter Apps, you can confirm that the Appdome protections in the Flutter Apps properly recognize your Threat-Event implementation by reviewing the Certified Secure\u2122 DevSecOps certificate for your build on Appdome.\n\n  ![Ios Android Cert 2 1000px](https://www.appdome.com/wp-content/uploads/2024/02/IOS-Android-cert_-2-1000px.png)\n\n  When Threat-Events implementation appears to be missing in your mobile application, the following indication will be shown in the Certified Secure DevSecOps certificate:\n\n  + **Android**:![Android Missing Threat Events Implementation](https://www.appdome.com/wp-content/uploads/2024/02/Android_Missing_Threat_Events_Implementation-650x130.png)\n  + **iOS**:![Ios Missing Threat Events Implementation](https://www.appdome.com/wp-content/uploads/2024/02/ios_missing_threat_events_implementation-650x132.png)\n\n  For information on how to retrieve the Certified Secure DevSecOps certification for your mobile application on Appdome, please visit the knowledge base article: [Using Certified Secure\u2122 Android & iOS Apps Build Certification in DevOps CI/CD](https://www.appdome.com/how-to/appsec-release-orchestration/certified-secure-android-ios/using-certified-secure-android-ios-apps-build-certification-in-devops-cicd/)\n\n## Related Articles\n\n* [Threat-Events\u2122, In-App Threat Intelligence in Kotlin Apps](https://www.appdome.com/how-to/advanced-threat-intelligence-android-ios/threat-events-ux-ui-control/threat-events-in-app-threat-intelligence-in-kotlin-apps/)\n* [Threat-Events\u2122, In-App Threat Intelligence in Native iOS Apps](https://www.appdome.com/how-to/advanced-threat-intelligence-android-ios/threat-events-ux-ui-control/threat-events-in-app-threat-intelligence-in-native-ios-apps/)\n* [Threat-Events\u2122, In-App Threat Intelligence in React Native Apps](https://www.appdome.com/how-to/advanced-threat-intelligence-android-ios/threat-events-ux-ui-control/threat-events-in-app-threat-intelligence-in-react-native-apps/)\n* [Threat-Events\u2122, In-App Threat Intelligence in Swift Apps](https://www.appdome.com/how-to/advanced-threat-intelligence-android-ios/threat-events-ux-ui-control/threat-events-in-app-threat-intelligence-in-swift-apps/)\n* [Threat-Events\u2122, In-App Threat Intelligence in Native Android Apps](https://www.appdome.com/how-to/advanced-threat-intelligence-android-ios/threat-events-ux-ui-control/threat-events-in-app-threat-intelligence-in-native-android-apps/)\n* [Threat-Events\u2122, In-App Threat Intelligence in Maui, Xamarin Apps](https://www.appdome.com/how-to/advanced-threat-intelligence-android-ios/threat-events-ux-ui-control/threat-events-in-app-threat-intelligence-in-xamarin-apps/)\n* [Implementing Threat Events \u2013 Best Practices](https://www.appdome.com/how-to/advanced-threat-intelligence-android-ios/threat-events-ux-ui-control/implementing-threat-events-best-practices/)\n* [How To Implement Threat-Events in Java](https://www.appdome.com/how-to/advanced-threat-intelligence-android-ios/threat-events-ux-ui-control/implementing-threat-events-in-code/)\n\n### How Do I Learn More?\n\nIf you have any questions, please send them our way at\u00a0[support.appdome.com](https://support.appdome.com/?__hstc=267077713.a252d6bafcc2ff9ea15f20f0e653391d.1692615574684.1704974180237.1704976923959.345&__hssc=267077713.6.1704976923959&__hsfp=1931022262)\u00a0or via the chat window on the Appdome platform.\n\n### Thank you!\n\nThanks for visiting\u00a0[**Appdome**](https://www.appdome.com/)! Our mission is to secure every app on the planet by making mobile app security easy. We hope we\u2019re living up to the mission with your project.\n\nWant a Demo?\n\nThreat-Events\u2122 UX/UI Control\n\n![](https://www.appdome.com/wp-content/uploads/2020/02/Appdome_Team_Photos_Tom_Tovar_BW.jpg)\n\nTomWe're here to help\n\n\n\n\nWe'll get back to you in 24 hours to schedule your demo.\n\n* [Home Page](https://www.appdome.com/)\n* [Dev+Sec Blog](https://www.appdome.com/dev-sec-blog/)\n* [Request A Demo](https://www.appdome.com/request-a-demo/appdome-home/)\n* [Platform](https://www.appdome.com/devsecops-tool-cicd/)\n* [Pricing](https://www.appdome.com/appdome-pricing/)\n* [About](https://www.appdome.com/about/)\n* [Patents](https://www.appdome.com/legal/patents/)\n* [Knowledge Base](https://www.appdome.com/how-to/)\n* [In The News](https://www.appdome.com/in-the-news/)\n* [Careers we\u2019re hiring!](https://www.appdome.com/about/work-at-appdome/)\n* [Terms Of Use](https://www.appdome.com/legal/terms-of-use/)\n* [Press Releases](https://www.appdome.com/press-releases/)\n* [Privacy Policy](https://www.appdome.com/legal/privacy-policy/)\n* [Contact Us](https://www.appdome.com/contact-us/)\n\n\n\n---\n\nREDWOOD CITY OFFICE\n\n* 3 Twin Dolphin Drive,   \n  Suite 375 Redwood City,   \n  CA 94065\n* Phone: [+1.650.567.6100](tel:+16505676100)   \n  Mobile: [+1.844.360.FUSE (3873)](tel:+1844360FUSE (3873))   \n  Email: [info@appdome.com](mailto:info@appdome.com)\n\nISRAEL OFFICE\n\n* 21 HaArba'a Street,\n* Phone: [+97235568332](tel:+97235568332)   \n  Email: [info@appdome.com](mailto:info@appdome.com)\n\nSearch for:\n\nFollow us\n\n\u00a92026 Appdome, Inc. All rights reserved. This Website requires the use of technical cookies and, with your consent, profiling, and third-party analytics to improve your experience.  \n If you continue to use our Website, or by clicking any items of our Website, you agree to this.\n\nWe use cookies to ensure that we give you the best experience on our website.\nIf you continue to use this site we will assume that you are happy with it.\nOk\n\n ![](https://px.ads.linkedin.com/collect/?pid=3167484&fmt=gif) \n\n## Search Appdome Solutions\n\nSearch\n\nSearch\n\n[![mobile app protection best practices](https://www.appdome.com/wp-content/uploads/2026/01/Mobile-App-Protection-Best-Practices-for-Developers-in-2026-170x111.png)](https://www.appdome.com/dev-sec-blog/mobile-app-protection-best-practices-for-developers/)\n\n### [Mobile App Protection Best Practices for Developers in 2026](https://www.appdome.com/dev-sec-blog/mobile-app-protection-best-practices-for-developers/)\n\nMobile app protection best practices for developers in 2026. Learn how to protect apps from AI malware, bots, ATO, and fraud \u2014 automated with Appdome.\n\nJan Sysmans \n\nJanuary 5, 2026\n\n[![Mobile App Attack Vectors](https://www.appdome.com/wp-content/uploads/2026/01/mobile-app-attack-vectors-170x111.png)](https://www.appdome.com/dev-sec-blog/top-mobile-app-attack-vectors/)\n\n### [Top 10 Mobile App Attack Vectors in 2026 And the Defense Architecture Required to Stop Them](https://www.appdome.com/dev-sec-blog/top-mobile-app-attack-vectors/)\n\nAI malware, deepfakes, and automated bots are the top mobile app attack vectors in 2026. Discover how to stop them with Appdome\u2019s defense architecture defense.\n\nJan Sysmans \n\nJanuary 1, 2026\n\n[![G2 Customer Reviews](https://www.appdome.com/wp-content/uploads/2025/12/G2-Reviews_-2025-Was-a-Banner-Year-for-Appdome-170x111.png)](https://www.appdome.com/dev-sec-blog/g2-customer-reviews-2025-banner-year-appdome/)\n\n### [G2 Customer Reviews Reveal 2025 Was a Banner Year for Appdome](https://www.appdome.com/dev-sec-blog/g2-customer-reviews-2025-banner-year-appdome/)\n\nG2 customer reviews show that 2025 marked a pivotal year for Appdome. The platform gained momentum as enterprises standardized on AI-native automation for mobile security, fraud prevention, and bot defense.\n\nTom Tovar \n\nDecember 28, 2025\n\n[![Android Bootloader Integrity Explained](https://www.appdome.com/wp-content/uploads/2025/12/android-bootloader-integrity-explained-170x111.png)](https://www.appdome.com/dev-sec-blog/android-bootloader-integrity-explained/)\n\n### [Why \u2018Unlocked Bootloader\u2019 Is a Broken Android Security Model](https://www.appdome.com/dev-sec-blog/android-bootloader-integrity-explained/)\n\nAndroid bootloader integrity is often reduced to a locked or unlocked state. This article explains why that model fails and how contextual bootloader signals improve identity and session trust.\n\nLiron Dror \n\nDecember 24, 2025\n\n[Dev+Sec Blog](/dev-sec-blog)\n\n-->"
}